{"version":3,"sources":["../../src/crypto.ts","../../src/implementations.ts","../../src/server.ts"],"names":["encoder","sign","value","secret","key","createKey","data","signature","hash","unsign","signed","index","byteStringToUint8Array","usages","byteString","array","i","createCookie","createCookieFactory","createCookieSessionStorage","createCookieSessionStorageFactory","createSessionStorage","createSessionStorageFactory","createMemorySessionStorage","createMemorySessionStorageFactory","originalErrorToString","createRequestHandler","build","mode","poweredByHeader","getLoadContext","handleRequest","createRemixRequestHandler","request","method","url","context","response","getStorefrontHeaders","headers"],"mappings":"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","file":"index.cjs","sourcesContent":["import type {SignFunction, UnsignFunction} from '@remix-run/server-runtime';\n\nconst encoder = new TextEncoder();\n\nexport const sign: SignFunction = async (value, secret) => {\n  const key = await createKey(secret, ['sign']);\n  const data = encoder.encode(value);\n  const signature = await crypto.subtle.sign('HMAC', key, data);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    '',\n  );\n\n  return value + '.' + hash;\n};\n\nexport const unsign: UnsignFunction = async (signed, secret) => {\n  const index = signed.lastIndexOf('.');\n  const value = signed.slice(0, index);\n  const hash = signed.slice(index + 1);\n\n  const key = await createKey(secret, ['verify']);\n  const data = encoder.encode(value);\n  const signature = byteStringToUint8Array(atob(hash));\n  const valid = await crypto.subtle.verify('HMAC', key, signature, data);\n\n  return valid ? value : false;\n};\n\nasync function createKey(\n  secret: string,\n  usages: CryptoKey['usages'],\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    {name: 'HMAC', hash: 'SHA-256'},\n    false,\n    usages,\n  );\n\n  return key;\n}\n\nfunction byteStringToUint8Array(byteString: string): Uint8Array {\n  const array = new Uint8Array(byteString.length);\n\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n\n  return array;\n}\n","import {\n  createCookieFactory,\n  createCookieSessionStorageFactory,\n  createMemorySessionStorageFactory,\n  createSessionStorageFactory,\n} from '@remix-run/server-runtime';\n\nimport {sign, unsign} from './crypto';\n\nexport const createCookie = createCookieFactory({sign, unsign});\nexport const createCookieSessionStorage =\n  createCookieSessionStorageFactory(createCookie);\nexport const createSessionStorage = createSessionStorageFactory(createCookie);\nexport const createMemorySessionStorage =\n  createMemorySessionStorageFactory(createSessionStorage);\n","/// <reference types=\"@shopify/hydrogen\" />\nimport {\n  createRequestHandler as createRemixRequestHandler,\n  type AppLoadContext,\n  type ServerBuild,\n} from '@remix-run/server-runtime';\nimport {createEventLogger} from './event-logger';\n\nconst originalErrorToString = Error.prototype.toString;\nError.prototype.toString = function () {\n  return this.stack || originalErrorToString.call(this);\n};\n\nexport function createRequestHandler<Context = unknown>({\n  build,\n  mode,\n  poweredByHeader = true,\n  getLoadContext,\n}: {\n  build: ServerBuild;\n  mode?: string;\n  poweredByHeader?: boolean;\n  getLoadContext?: (request: Request) => Promise<Context> | Context;\n}) {\n  const handleRequest = createRemixRequestHandler(build, mode);\n\n  return async (request: Request) => {\n    const method = request.method;\n\n    if ((method === 'GET' || method === 'HEAD') && request.body) {\n      return new Response(`${method} requests cannot have a body`, {\n        status: 400,\n      });\n    }\n\n    const url = new URL(request.url);\n\n    if (url.pathname.includes('//')) {\n      return new Response(null, {\n        status: 301,\n        headers: {\n          location: url.pathname.replace(/\\/+/g, '/'),\n        },\n      });\n    }\n\n    const context = getLoadContext\n      ? ((await getLoadContext(request)) as AppLoadContext)\n      : undefined;\n\n    if (process.env.NODE_ENV === 'development' && context) {\n      // Store logger in globalThis so it can be accessed from the worker.\n      // The global property must be different from the binding name,\n      // otherwise Miniflare throws an error when accessing it.\n      globalThis.__H2O_LOG_EVENT ??= createEventLogger(context);\n    }\n\n    const startTime = Date.now();\n\n    const response = await handleRequest(request, context);\n\n    if (poweredByHeader) {\n      response.headers.append('powered-by', 'Shopify, Hydrogen');\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      globalThis.__H2O_LOG_EVENT?.({\n        eventType: 'request',\n        url: request.url,\n        requestId: request.headers.get('request-id'),\n        purpose: request.headers.get('purpose'),\n        startTime,\n        responseInit: {\n          status: response.status,\n          statusText: response.statusText,\n          headers: Array.from(response.headers.entries()),\n        } satisfies ResponseInit,\n      });\n    }\n\n    return response;\n  };\n}\n\ntype StorefrontHeaders = {\n  requestGroupId: string | null;\n  buyerIp: string | null;\n  cookie: string | null;\n  purpose: string | null;\n};\n\nexport function getStorefrontHeaders(request: Request): StorefrontHeaders {\n  const headers = request.headers;\n  return {\n    requestGroupId: headers.get('request-id'),\n    buyerIp: headers.get('oxygen-buyer-ip'),\n    cookie: headers.get('cookie'),\n    purpose: headers.get('purpose'),\n  };\n}\n"]}